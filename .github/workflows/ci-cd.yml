name: GHCR Smoke Test

on:
  workflow_dispatch:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]   # secrets only available for same-repo PRs

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_OWNER: ${{ secrets.PAT_USERNAME }}   # force pushes into PAT owner namespace
  PKG_NAME: ghcr-auth-smoke

jobs:
  smoke:
    runs-on: ubuntu-latest
    # allow PRs but block forks (no secrets there)
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false
    steps:
      - name: Checkout (tiny context only)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Log in to GHCR with PAT
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.PAT_USERNAME }}   # e.g. "maquino1985"
          password: ${{ secrets.CR_PAT }}

      - name: Build tiny test image
        run: |
          cat > Dockerfile <<'EOF'
          FROM busybox:latest
          CMD ["echo","ok"]
          EOF
          docker build -t ghcr.io/${{ env.IMAGE_OWNER }}/${{ env.PKG_NAME }}:local .

      - name: Tag & Push (latest, run, sha)
        id: push
        shell: bash
        run: |
          set -euo pipefail
          REPO="ghcr.io/${IMAGE_OWNER}/${PKG_NAME}"
          TAG_LATEST="latest"
          TAG_RUN="run-${GITHUB_RUN_ID}"
          TAG_SHA="sha-${GITHUB_SHA:0:12}"

          for TAG in "$TAG_LATEST" "$TAG_RUN" "$TAG_SHA"; do
            echo "Tagging -> ${REPO}:${TAG}"
            docker tag "${REPO}:local" "${REPO}:${TAG}"
            echo "Pushing -> ${REPO}:${TAG}"
            docker push "${REPO}:${TAG}"
          done

          # expose the three tags to cleanup step
          echo "tag_latest=${TAG_LATEST}" >> $GITHUB_OUTPUT
          echo "tag_run=${TAG_RUN}"       >> $GITHUB_OUTPUT
          echo "tag_sha=${TAG_SHA}"       >> $GITHUB_OUTPUT

      - name: Cleanup created versions (best effort)
        if: always()   # try even if push failed; it's safe
        uses: actions/github-script@v7
        env:
          PKG_OWNER: ${{ env.IMAGE_OWNER }}
          PKG_NAME:  ${{ env.PKG_NAME }}
          TAG_LATEST: ${{ steps.push.outputs.tag_latest }}
          TAG_RUN:    ${{ steps.push.outputs.tag_run }}
          TAG_SHA:    ${{ steps.push.outputs.tag_sha }}
        with:
          github-token: ${{ secrets.CR_PAT }}  # needs package delete; if missing, it will just log
          script: |
            const owner = process.env.PKG_OWNER;
            const pkg = process.env.PKG_NAME;
            const targets = [process.env.TAG_LATEST, process.env.TAG_RUN, process.env.TAG_SHA].filter(Boolean);
            const del = async (version_id) => {
              try {
                await github.request('DELETE /users/{username}/packages/container/{package_name}/versions/{package_version_id}', {
                  username: owner, package_name: pkg, package_version_id: version_id
                });
                console.log(`Deleted version ${version_id}`);
              } catch (e) {
                console.log(`Delete failed for ${version_id}: ${e.status || ''} ${e.message}`);
              }
            };

            try {
              // List versions
              const { data: versions } = await github.request('GET /users/{username}/packages/container/{package_name}/versions', {
                username: owner, package_name: pkg, per_page: 100
              });
              // Find versions that match our tags and delete only those
              for (const v of versions) {
                const tags = (v.metadata?.container?.tags) || [];
                if (tags.some(t => targets.includes(t))) {
                  console.log(`Cleaning version ${v.id} with tags [${tags.join(',')}]`);
                  await del(v.id);
                }
              }
            } catch (e) {
              console.log(`Cleanup listing failed: ${e.status || ''} ${e.message}`);
              console.log('This is non-fatal; images may remain in GHCR.');
            }
